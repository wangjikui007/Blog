<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Set详解]]></title>
    <url>%2FSet%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$$\text{ Set 详解 }$$所谓set，就是STL里的集合。可以快速地插入和查找某个元素。 声明setset&lt;type&gt; name; 1234567set&lt;int&gt; s1;set&lt;char&gt; s2;//---------------------------struct qwq&#123; ...;&#125;;set&lt;qwq&gt; s3; 应用set插入使用insert()函数来插入set。 1234set&lt;int&gt; s;s.insert(1);s.insert(2);... 查找使用insert()函数查找这个变量的值是不是在set里。 是返回true，否则返回false。 1234set&lt;int&gt; s;s.insert(1);if(s.count(1))printf("hehe");else printf("wawa"); 判空empty()函数可以返回该set是否为空的信息。 是返回true，否则返回false。 123set&lt;int&gt; s;s.insert(1);s.empty(); //返回0 删除erase()函数可以删除set中的一个元素。 12345set&lt;int&gt; s;s.insert(1);s.empty(); //返回0s.erase(1);s.empty(); //返回1 遍历使用迭代器！ 1234567891011121314151617set&lt;int&gt; s;s.insert(1);s.insert(3);s.insert(4);s.insert(2);for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl;&#125;//由于set会自动给元素排序//输出:/*1234*/ 完结撒花✿✿ヽ(°▽°)ノ✿！QAQ~]]></content>
      <categories>
        <category>算法详解</category>
      </categories>
      <tags>
        <tag>算法详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 Luogu P3472 MAF-Mafia]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3-Luogu-P3472-MAF-Mafia%2F</url>
    <content type="text"><![CDATA[$$\text{ Luogu P3472 MAF-Mafia }$$原题 题目描述：给定n个神枪手，每个神枪手瞄准一个人，以一定顺序开枪，问最少和最多死多少人 Solution: 最少的情况是每个联通块只有入度为零的点活下来（如果是环就留一个人）；最多的情况就是从入度为零的开始到结束。 注意自环！ AC Code:吴老师那玄学的码风 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int const N=2000001;int n,used[N],p[N],s[N],ind[N],size[N];int head,tail,q[N],d[N];bool f[N];int dfs(int x,int y)&#123; used[x]=y; if (used[p[x]]==0) dfs(p[x],y); used[x]=used[p[x]];&#125;int main()&#123; freopen("mafia.in","r",stdin); freopen("mafia.out","w",stdout); scanf("%d\n",&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); ind[p[i]]++; &#125; int T=0; for (int i=1;i&lt;=n;i++) if (used[i]==0) dfs(i,++T); for (int i=1;i&lt;=T;i++) s[i]=-1; for (int i=1;i&lt;=n;i++) s[used[i]]=0; for (int i=1;i&lt;=n;i++) if (ind[i]==0) s[used[i]]++; int Mans=0,mans=0; for (int i=1;i&lt;=n;i++) size[used[i]]++; for (int i=1;i&lt;=T;i++) if ((s[i]==0) &amp;&amp; (size[i]&gt;1)) Mans++; else if (s[i]&gt;0) Mans+=s[i]; for (int i=1;i&lt;=T;i++) s[i]=0; for (int i=1;i&lt;=n;i++) s[used[i]]++; head=1; tail=0; for (int i=1;i&lt;=n;i++) if (ind[i]==0) &#123; q[++tail]=i; f[i]=true; &#125; while (head&lt;=tail) &#123; int x=q[head]; s[used[x]]--; if (d[x]==1) &#123; mans++; &#125; if (d[x]==0)&#123; d[p[x]]=1; &#125; ind[p[x]]--; if ((ind[p[x]]==0) &amp;&amp; (!f[p[x]])) &#123; q[++tail]=p[x]; f[p[x]]=true; &#125; head++; &#125; for (int i=1;i&lt;=n;i++) if ((!f[i]) &amp;&amp; (d[i]==1)) &#123; q[++tail]=i; f[i]=true; &#125; while (head&lt;=tail) &#123; int x=q[head]; s[used[x]]--; if (d[x]==1) &#123; mans++; &#125; if (d[x]==0)&#123; d[p[x]]=1; &#125; ind[p[x]]--; if ((ind[p[x]]==0) &amp;&amp; (!f[p[x]])) &#123; q[++tail]=p[x]; f[p[x]]=true; &#125; head++; &#125; for (int i=1;i&lt;=T;i++) &#123; mans+=(1+s[i])/2; &#125; printf("%d %d\n",mans,n-Mans); return 0; &#125; 完结撒花✿✿ヽ(°▽°)ノ✿！]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI-9.23-搜索]]></title>
    <url>%2FZROI-9-23-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[$$\text{ 搜索 }$$ $$\text{ 引入——递归 }$$这是一个递归求幂的程序 123int f(int x,int y)&#123; return f(x,y-1)*x;&#125; 没有边界条件！ $$\text{ Luogu P1706 全排列问题 }$$原题 输出自然数1到n所有不重复的排列，即n的全排列，要求所产生的任一数字序列中不允许出现重复的数字。 数据范围：$1\leq n\leq 9$ STL大法吼！1next_permutation(a,a+n);//求下一个排列 正解正解当然是搜索啦qwq AC Code: 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n,a[11];bool book[11];void dfs(int x)&#123; if(x&gt;n)&#123; for(int i=1;i&lt;=n;i++)cout&lt;&lt;" "&lt;&lt;a[i]; cout&lt;&lt;endl; &#125; else&#123; for(int i=1;i&lt;=n;i++)&#123; if(!book[i])&#123; a[x]=i; book[i]=true; dfs(x+1); book[i]=false; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(1); return 0;&#125; $$\text{ Luogu P2404 自然数的拆分问题 }$$原题 任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。 歪解：打表qwq感谢@minecraft_herobrine的代码 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt; using namespace std;int main()&#123; int n; scanf("%d",&amp;n); if(n==2) printf("1+1"); if(n==3) printf("1+1+1\n1+2"); if(n==4) printf("1+1+1+1\n1+1+2\n1+3\n2+2"); if(n==5) printf("1+1+1+1+1\n1+1+1+2\n1+1+3\n1+2+2\n1+4\n2+3"); if(n==6)printf("1+1+1+1+1+1\n1+1+1+1+2\n1+1+1+3\n1+1+2+2\n1+1+4\n1+2+3\n1+5\n2+2+2\n2+4\n3+3"); if(n==7)&#123; printf("1+1+1+1+1+1+1\n1+1+1+1+1+2\n1+1+1+1+3\n1+1+1+2+2\n1+1+1+4\n"); printf("1+1+2+3\n1+1+5\n1+2+2+2\n1+2+4\n1+3+3\n1+6\n2+2+3\n2+5\n3+4"); &#125; if(n==8)&#123; printf("1+1+1+1+1+1+1+1\n1+1+1+1+1+1+2\n1+1+1+1+1+3\n"); printf("1+1+1+1+2+2\n1+1+1+1+4\n1+1+1+2+3\n1+1+1+5\n"); printf("1+1+2+2+2\n1+1+2+4\n1+1+3+3\n1+1+6\n1+2+2+3\n1+2+5\n1+3+4\n1+7\n"); printf("2+2+2+2\n2+2+4\n2+3+3\n2+6\n3+5\n4+4"); &#125; return 0;&#125; 正解仍然是搜索不然这节课讲什么？ AC Code: 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;#define n 15#define For(i,a,b) for(int i=a;i&lt;=b;i++)int N,A[n];void dfs(int d,int last,int sum)&#123; if(sum==0)&#123; if(d==2)return; For(i,1,d-1)printf("%d%c",A[i],"+\n"[i==d-1]); return; &#125; For(i,last,sum)A[d]=i,dfs(d+1,i,sum-i);&#125;int main()&#123; scanf("%d",&amp;N); dfs(1,1,N); return 0;&#125; 强势压行qwq $$\text{ Luogu P1219 八皇后 }$$原题 检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。 正解还是搜索我这样下去是不是要烦死你 AC Code: 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define For(i,a,b) for(int i=a;i&lt;=b;i++)#define Rep(i,a,b) for(int i=a;i&gt;=b;i--)#define n 105int N,M,A[n],B[n],C[n],D[n];void DFS(int d)&#123; if(d&gt;N)&#123; M++; if(M&lt;=3)&#123; For(i,1,N)printf("%d ",A[i]); puts(""); &#125; return; &#125; For(i,1,N) if(!B[i]&amp;&amp;!C[i+d]&amp;&amp;!D[i-d+N])&#123; A[d]=i; B[i]=1; C[i+d]=1; D[i-d+N]=1; DFS(d+1); B[i]=0; C[i+d]=0; D[i-d+N]=0; &#125;&#125;int main()&#123; scanf("%d",&amp;N); DFS(1); printf("%d\n",M); return 0;&#125; 这次没压行qwq $$\text{ Luogu P1657 选书 }$$原题 你一共有$n$本书。有$n$个人参加培训，每个人有两本在编号为1~n之间的喜欢的书。求每个人都拿到自己喜欢的书的方案数。 So easy! 妈妈再也不用担心我的学习！ 正解又是搜索烦死你 AC Code: 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans,A[25],B[25],V[25];void dfs(int d)&#123; if(d&gt;n)&#123; ans++; return; &#125; if(!V[A[d]])V[A[d]]=1,dfs(d+1),V[A[d]]=0; if(!V[B[d]])V[B[d]]=1,dfs(d+1),V[B[d]]=0;&#125;int main()&#123; cin&gt;&gt;n; if(n==0)return puts("0"),0; for(int i=1;i&lt;=n;i++)cin&gt;&gt;A[i]&gt;&gt;B[i]; dfs(1); cout&lt;&lt;ans; return 0;&#125; $$\text{ CODE[VS] 1116 四色问题 }$$原题 给定N（小于等于8）个点的地图，以及地图上各点的相邻关系，请输出用4种颜色将地图涂色的所有方案数（要求相邻两点不能涂成相同的颜色） 搜索：我又来了哭QAQ AC Code: 123456789101112131415161718192021222324252627282930313233#include &lt;cstdlib&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int map[8][8] = &#123;&#125;, n, color[8] = &#123;&#125;;int search(int a) &#123; bool flag[4] = &#123;&#125;; int i, num = 0, ans = 0; for (i = 0; i &lt; a; i++) if (map[a][i]) flag[color[i]] = true; for (i = 0; i &lt;= 3; i++) if (!flag[i]) num++; if (a == n - 1) return num; else for (i = 0; i &lt;= 3; i++) if (!flag[i]) &#123; color[a] = i; ans += search(a + 1); &#125; return ans;&#125;int main() &#123; int i, j; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; cout &lt;&lt; search(0) &lt;&lt; endl; return 0;&#125; $$\text{ 完结撒花✿✿ヽ(°▽°)ノ✿ }$$QAQ]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI 9.9 排序]]></title>
    <url>%2FZROI-9-9-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[$$ O(n^2)\text{ 排序算法 }$$ $$\text{ 选择排序 }$$每次找最大（或最小）的一个数，放到对应位置。 $$\text{ 插入排序 }$$for一遍，每次往前查，找到相应位置。 $$\text{ 冒泡排序 }$$n轮，每次比较相邻元素。 123for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(a[i]&gt;=a[j])swap(a[i],a[j]); 思考：逆序对 $$ O(nlogn)\text{ 排序算法 }$$ $$\text{ 快速排序 }$$ 每次随机选择一个数作为分界点 大的放右边小的放左边 递归对两边分治 1234567891011121314void work(int L,int R)&#123; if (L&gt;=R) return; int i=L,j=R,tmp=A[(L+R)/2]; while (i&lt;=j)&#123; while (i&lt;=j&amp;&amp;A[i]&lt;tmp) i++; while (i&lt;=j&amp;&amp;A[j]&gt;tmp) j--; if (i&lt;=j)&#123; swap(A[i],A[j]); i++,j--; &#125; &#125; if (i&lt;R) work(i,R); if (L&lt;j) work(L,j);&#125; 如知道随机种子或每次选中间数，如何卡至$O(n^2)$？ 使中间数为最小值。 STL大法吼！12345678910111213sort(a,a+n); //a[0..n-1]sort(a.begin(),a.end()); //vectorsort(a.rbegin(),a.rend()); //sort+reverse (vector)//------------------------------------------------bool cmp(aaa a,aaa b)&#123; return a.aa&lt;b.aa;&#125;sort(a,a+n,cmp);//------------------------------------------------bool operator &lt; (aaa a,aaa b)&#123; return a.aa&lt;b.aa;&#125;sort(a,a+n); STL比较函数当两个数相等的时候一定要返回0！！！ Reverse Sort: 给你一个序列，每次操作能翻转一个区间，代价为这个区间的长度 在$O(nlogn)$的总代价内将整个序列排序 $$\text{ 归并排序 }$$ 从中间断开为左右区间 递归对两边分治 对已经有序的两边区间进行归并 123456789101112void work(int L,int R)&#123; if (L==R) return; work(L,Mid); work(Mid+1,R); int tl=L,tr=Mid+1,t=L; while (tl&lt;=Mid&amp;&amp;tr&lt;=R)&#123; if (A[tl]&lt;A[tr]) B[t++]=A[tl++];else B[t++]=A[tr++]; &#125; while (tl&lt;=Mid) B[t++]=A[tl++]; while (tr&lt;=R) B[t++]=A[tr++]; for (int i=L;i&lt;=R;i++) A[i]=B[i];&#125; STL大法吼！区间合并：inplace_merge 12//a[0..n-1],a[n..n*2-1]合并inplace_merge(a,a+n,a+n*2); 扩展：归并排序求逆序对 $$\text{ 不基于比较的排序算法 }$$ $$\text{ 桶排序 }$$一个萝卜一个坑 时间复杂度$O(n+m)$ $$\text{ 基数排序 }$$ 分段分别桶排，从低位到高位依次作为关键字 比如设当前所有数已经按后𝑘位排好了序，那么后𝑘+1位的排序就是按第𝑘+1位排，相同的就按原顺序排 视段长的大小，开这么多的桶，求出比𝑥小的数有多少个，然后快速把每个数放到该放的位置去。 [WC2017] 挑战]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题 代码当然是可以的 12345#include &lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; latex qwq $1$]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
