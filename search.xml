<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ZROI 10.2 高精度]]></title>
    <url>%2FZROI-10-2-%E9%AB%98%E7%B2%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[$$\text{ 高精度 }$$ 高精度数的表示方法 使用一个一位数组来储存一个数，每个元素储存原数的某一位或某连续几位。 一个方便的操作是把数的长度存在数组下标为0的位置上。 应用 读入一个长度为$n$的数，把它倒序存在一个数组里。 1234scanf("%s",s+1);for(int i=1;i&lt;=strlen(s+1);i++)&#123; a[i]=s[strlen(s+1)-i+1]-'0';&#125; 再写出压四位的写法 123456789101112131415//输出压四位int o[4];bool con=true;for(int i=a[0];i&gt;=1;i--)&#123; for(int j=0;j&lt;4;j++)&#123; o[j]=a[i]%10;a[i]/=10; &#125; for(int j=3;j&gt;=0;j--)&#123; if(con==true)&#123; if(o[j]==0) continue; else con=false; &#125; printf("%d",o[j]); &#125;&#125; 比较大小123456789if(lena&gt;lenb)return 1;else if(lenb&gt;lena)return -1;else&#123; for(int i=1;i&lt;=lena;i++)&#123; if(a[i]&gt;b[i])return 1; else if(a[i]&lt;b[i])return -1; &#125; return 0;&#125; 高精度+int先在最低位加上int，然后一步一步进位。 123456a[1]+=b;for(int i=1;i&lt;=lena;i++)&#123; a[i+1]+=a[i]/A; a[i]%=A; if(a[lena+1])++lena;&#125; 高精度+高精度1234567lena=max(lena,lenb);for(int i=1;i&lt;=lena;i++)&#123; a[i]+=b[i]; a[i+1]+=a[i]/A; a[i]%=A; if(a[lena+1])lena++;&#125; 高精度-高精度$$ \text{a是否为负}\left\{\begin{aligned}\text{是}\left\{ \begin{aligned} \text{正-负}\\ \text{负-负} \end{aligned} \right.\\\text{否}\left\{ \begin{aligned} \text{正-正}\\ \text{负-正} \end{aligned} \right.\\\end{aligned}\right.$$ $\LaTeX$真是毒瘤 高精度乘法高精度$\times$int a$\times$b 处理进位 1234567for(int i=1;i&lt;=lena;i++)&#123; a[i]*=b; a[i+1]+=a[i]/A; a[i]%=A; if(a[lena+1])lena++;&#125;// a和b开long long! 高精度$\times$高精度 不压位 建立一个临时数组$c$！ 12345678910int c[];lenc=lena+lenb-1;for(int i=1;i&lt;=lena;i++)&#123; for(int j=1;j&lt;=lenb;j++)&#123; c[i+j-1]+=a[i]*b[j]; c[i+j]+=c[i+j-1]/10; c[i+j-1]%=10; &#125;&#125;if(c[lenc+1])lenc++; 高精度除法高精度$\div$int像竖式一样挨个除。 毒瘤的$\LaTeX$打不出来竖式 123456int a[],b,r=0;for(int i=lena;i&gt;0;--i)&#123; r=r*10+a[i]; a[i]=r/b; r%=b;&#125; 压位？ 123456int a[],b,r=0;for(int i=lena;i&gt;0;--i)&#123; r=r*A+a[i]; a[i]=r/b; r%=b;&#125; 习题部分NOIp2003 麦森数原题 读入$P (1000&lt;P&lt;3100000)$，计算$2^P-1$在十进制下的位数和后500位数字。 第一问： $X$在十进制中的位数是$[log_{10}X]+1$ 所以，$2^P-1$在十进制中的位数就是$P$！ 第二问： 使用快速幂 求$a^b$的程序： 12345678int ans=1,w=a;for(;b;b/=2)&#123; if(b%2)&#123; ans*=w; &#125; w*=w;&#125;//ans --&gt; 答案 高精求$2^P-1$：$ans\times w$ 高精度乘法 NOIp2012 国王游戏恰逢$H$国国庆，国王邀请$n$位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这$n$位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 贪心策略： person left right king $a_0$ $b_0$ $P_1$ $a_1$ $b_1$ $P_2$ $a_2$ $b_2$ 使$a_1\times b_1 &lt; a_2 \times b_2$。 就是排在前面的左手和右手的乘积小。]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set详解]]></title>
    <url>%2FSet%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$$\text{ Set 详解 }$$所谓set，就是STL里的集合。可以快速地插入和查找某个元素。 声明setset&lt;type&gt; name; 1234567set&lt;int&gt; s1;set&lt;char&gt; s2;//---------------------------struct qwq&#123; ...;&#125;;set&lt;qwq&gt; s3; 应用set插入使用insert()函数来插入set。 1234set&lt;int&gt; s;s.insert(1);s.insert(2);... 查找使用insert()函数查找这个变量的值是不是在set里。 是返回true，否则返回false。 1234set&lt;int&gt; s;s.insert(1);if(s.count(1))printf("hehe");else printf("wawa"); 判空empty()函数可以返回该set是否为空的信息。 是返回true，否则返回false。 123set&lt;int&gt; s;s.insert(1);s.empty(); //返回0 删除erase()函数可以删除set中的一个元素。 12345set&lt;int&gt; s;s.insert(1);s.empty(); //返回0s.erase(1);s.empty(); //返回1 遍历使用迭代器！ 1234567891011121314151617set&lt;int&gt; s;s.insert(1);s.insert(3);s.insert(4);s.insert(2);for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl;&#125;//由于set会自动给元素排序//输出:/*1234*/ 完结撒花✿✿ヽ(°▽°)ノ✿！QAQ~]]></content>
      <categories>
        <category>算法详解</category>
      </categories>
      <tags>
        <tag>算法详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 Luogu P3472 MAF-Mafia]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3-Luogu-P3472-MAF-Mafia%2F</url>
    <content type="text"><![CDATA[$$\text{ Luogu P3472 MAF-Mafia }$$原题 题目描述：给定n个神枪手，每个神枪手瞄准一个人，以一定顺序开枪，问最少和最多死多少人 Solution: 最少的情况是每个联通块只有入度为零的点活下来（如果是环就留一个人）；最多的情况就是从入度为零的开始到结束。 注意自环！ AC Code:吴老师那玄学的码风 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int const N=2000001;int n,used[N],p[N],s[N],ind[N],size[N];int head,tail,q[N],d[N];bool f[N];int dfs(int x,int y)&#123; used[x]=y; if (used[p[x]]==0) dfs(p[x],y); used[x]=used[p[x]];&#125;int main()&#123; freopen("mafia.in","r",stdin); freopen("mafia.out","w",stdout); scanf("%d\n",&amp;n); for (int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;p[i]); ind[p[i]]++; &#125; int T=0; for (int i=1;i&lt;=n;i++) if (used[i]==0) dfs(i,++T); for (int i=1;i&lt;=T;i++) s[i]=-1; for (int i=1;i&lt;=n;i++) s[used[i]]=0; for (int i=1;i&lt;=n;i++) if (ind[i]==0) s[used[i]]++; int Mans=0,mans=0; for (int i=1;i&lt;=n;i++) size[used[i]]++; for (int i=1;i&lt;=T;i++) if ((s[i]==0) &amp;&amp; (size[i]&gt;1)) Mans++; else if (s[i]&gt;0) Mans+=s[i]; for (int i=1;i&lt;=T;i++) s[i]=0; for (int i=1;i&lt;=n;i++) s[used[i]]++; head=1; tail=0; for (int i=1;i&lt;=n;i++) if (ind[i]==0) &#123; q[++tail]=i; f[i]=true; &#125; while (head&lt;=tail) &#123; int x=q[head]; s[used[x]]--; if (d[x]==1) &#123; mans++; &#125; if (d[x]==0)&#123; d[p[x]]=1; &#125; ind[p[x]]--; if ((ind[p[x]]==0) &amp;&amp; (!f[p[x]])) &#123; q[++tail]=p[x]; f[p[x]]=true; &#125; head++; &#125; for (int i=1;i&lt;=n;i++) if ((!f[i]) &amp;&amp; (d[i]==1)) &#123; q[++tail]=i; f[i]=true; &#125; while (head&lt;=tail) &#123; int x=q[head]; s[used[x]]--; if (d[x]==1) &#123; mans++; &#125; if (d[x]==0)&#123; d[p[x]]=1; &#125; ind[p[x]]--; if ((ind[p[x]]==0) &amp;&amp; (!f[p[x]])) &#123; q[++tail]=p[x]; f[p[x]]=true; &#125; head++; &#125; for (int i=1;i&lt;=T;i++) &#123; mans+=(1+s[i])/2; &#125; printf("%d %d\n",mans,n-Mans); return 0; &#125; 完结撒花✿✿ヽ(°▽°)ノ✿！]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI-9.23-搜索]]></title>
    <url>%2FZROI-9-23-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[$$\text{ 搜索 }$$ $$\text{ 引入——递归 }$$这是一个递归求幂的程序 123int f(int x,int y)&#123; return f(x,y-1)*x;&#125; 没有边界条件！ $$\text{ Luogu P1706 全排列问题 }$$原题 输出自然数1到n所有不重复的排列，即n的全排列，要求所产生的任一数字序列中不允许出现重复的数字。 数据范围：$1\leq n\leq 9$ STL大法吼！1next_permutation(a,a+n);//求下一个排列 正解正解当然是搜索啦qwq AC Code: 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n,a[11];bool book[11];void dfs(int x)&#123; if(x&gt;n)&#123; for(int i=1;i&lt;=n;i++)cout&lt;&lt;" "&lt;&lt;a[i]; cout&lt;&lt;endl; &#125; else&#123; for(int i=1;i&lt;=n;i++)&#123; if(!book[i])&#123; a[x]=i; book[i]=true; dfs(x+1); book[i]=false; &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(1); return 0;&#125; $$\text{ Luogu P2404 自然数的拆分问题 }$$原题 任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。 歪解：打表qwq感谢@minecraft_herobrine的代码 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt; using namespace std;int main()&#123; int n; scanf("%d",&amp;n); if(n==2) printf("1+1"); if(n==3) printf("1+1+1\n1+2"); if(n==4) printf("1+1+1+1\n1+1+2\n1+3\n2+2"); if(n==5) printf("1+1+1+1+1\n1+1+1+2\n1+1+3\n1+2+2\n1+4\n2+3"); if(n==6)printf("1+1+1+1+1+1\n1+1+1+1+2\n1+1+1+3\n1+1+2+2\n1+1+4\n1+2+3\n1+5\n2+2+2\n2+4\n3+3"); if(n==7)&#123; printf("1+1+1+1+1+1+1\n1+1+1+1+1+2\n1+1+1+1+3\n1+1+1+2+2\n1+1+1+4\n"); printf("1+1+2+3\n1+1+5\n1+2+2+2\n1+2+4\n1+3+3\n1+6\n2+2+3\n2+5\n3+4"); &#125; if(n==8)&#123; printf("1+1+1+1+1+1+1+1\n1+1+1+1+1+1+2\n1+1+1+1+1+3\n"); printf("1+1+1+1+2+2\n1+1+1+1+4\n1+1+1+2+3\n1+1+1+5\n"); printf("1+1+2+2+2\n1+1+2+4\n1+1+3+3\n1+1+6\n1+2+2+3\n1+2+5\n1+3+4\n1+7\n"); printf("2+2+2+2\n2+2+4\n2+3+3\n2+6\n3+5\n4+4"); &#125; return 0;&#125; 正解仍然是搜索不然这节课讲什么？ AC Code: 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;#define n 15#define For(i,a,b) for(int i=a;i&lt;=b;i++)int N,A[n];void dfs(int d,int last,int sum)&#123; if(sum==0)&#123; if(d==2)return; For(i,1,d-1)printf("%d%c",A[i],"+\n"[i==d-1]); return; &#125; For(i,last,sum)A[d]=i,dfs(d+1,i,sum-i);&#125;int main()&#123; scanf("%d",&amp;N); dfs(1,1,N); return 0;&#125; 强势压行qwq $$\text{ Luogu P1219 八皇后 }$$原题 检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。 正解还是搜索我这样下去是不是要烦死你 AC Code: 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define For(i,a,b) for(int i=a;i&lt;=b;i++)#define Rep(i,a,b) for(int i=a;i&gt;=b;i--)#define n 105int N,M,A[n],B[n],C[n],D[n];void DFS(int d)&#123; if(d&gt;N)&#123; M++; if(M&lt;=3)&#123; For(i,1,N)printf("%d ",A[i]); puts(""); &#125; return; &#125; For(i,1,N) if(!B[i]&amp;&amp;!C[i+d]&amp;&amp;!D[i-d+N])&#123; A[d]=i; B[i]=1; C[i+d]=1; D[i-d+N]=1; DFS(d+1); B[i]=0; C[i+d]=0; D[i-d+N]=0; &#125;&#125;int main()&#123; scanf("%d",&amp;N); DFS(1); printf("%d\n",M); return 0;&#125; 这次没压行qwq $$\text{ Luogu P1657 选书 }$$原题 你一共有$n$本书。有$n$个人参加培训，每个人有两本在编号为1~n之间的喜欢的书。求每个人都拿到自己喜欢的书的方案数。 So easy! 妈妈再也不用担心我的学习！ 正解又是搜索烦死你 AC Code: 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans,A[25],B[25],V[25];void dfs(int d)&#123; if(d&gt;n)&#123; ans++; return; &#125; if(!V[A[d]])V[A[d]]=1,dfs(d+1),V[A[d]]=0; if(!V[B[d]])V[B[d]]=1,dfs(d+1),V[B[d]]=0;&#125;int main()&#123; cin&gt;&gt;n; if(n==0)return puts("0"),0; for(int i=1;i&lt;=n;i++)cin&gt;&gt;A[i]&gt;&gt;B[i]; dfs(1); cout&lt;&lt;ans; return 0;&#125; $$\text{ CODE[VS] 1116 四色问题 }$$原题 给定N（小于等于8）个点的地图，以及地图上各点的相邻关系，请输出用4种颜色将地图涂色的所有方案数（要求相邻两点不能涂成相同的颜色） 搜索：我又来了哭QAQ AC Code: 123456789101112131415161718192021222324252627282930313233#include &lt;cstdlib&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int map[8][8] = &#123;&#125;, n, color[8] = &#123;&#125;;int search(int a) &#123; bool flag[4] = &#123;&#125;; int i, num = 0, ans = 0; for (i = 0; i &lt; a; i++) if (map[a][i]) flag[color[i]] = true; for (i = 0; i &lt;= 3; i++) if (!flag[i]) num++; if (a == n - 1) return num; else for (i = 0; i &lt;= 3; i++) if (!flag[i]) &#123; color[a] = i; ans += search(a + 1); &#125; return ans;&#125;int main() &#123; int i, j; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; cout &lt;&lt; search(0) &lt;&lt; endl; return 0;&#125; $$\text{ 完结撒花✿✿ヽ(°▽°)ノ✿ }$$QAQ]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI 9.9 排序]]></title>
    <url>%2FZROI-9-9-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[$$ O(n^2)\text{ 排序算法 }$$ $$\text{ 选择排序 }$$每次找最大（或最小）的一个数，放到对应位置。 $$\text{ 插入排序 }$$for一遍，每次往前查，找到相应位置。 $$\text{ 冒泡排序 }$$n轮，每次比较相邻元素。 123for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(a[i]&gt;=a[j])swap(a[i],a[j]); 思考：逆序对 $$ O(nlogn)\text{ 排序算法 }$$ $$\text{ 快速排序 }$$ 每次随机选择一个数作为分界点 大的放右边小的放左边 递归对两边分治 1234567891011121314void work(int L,int R)&#123; if (L&gt;=R) return; int i=L,j=R,tmp=A[(L+R)/2]; while (i&lt;=j)&#123; while (i&lt;=j&amp;&amp;A[i]&lt;tmp) i++; while (i&lt;=j&amp;&amp;A[j]&gt;tmp) j--; if (i&lt;=j)&#123; swap(A[i],A[j]); i++,j--; &#125; &#125; if (i&lt;R) work(i,R); if (L&lt;j) work(L,j);&#125; 如知道随机种子或每次选中间数，如何卡至$O(n^2)$？ 使中间数为最小值。 STL大法吼！12345678910111213sort(a,a+n); //a[0..n-1]sort(a.begin(),a.end()); //vectorsort(a.rbegin(),a.rend()); //sort+reverse (vector)//------------------------------------------------bool cmp(aaa a,aaa b)&#123; return a.aa&lt;b.aa;&#125;sort(a,a+n,cmp);//------------------------------------------------bool operator &lt; (aaa a,aaa b)&#123; return a.aa&lt;b.aa;&#125;sort(a,a+n); STL比较函数当两个数相等的时候一定要返回0！！！ Reverse Sort: 给你一个序列，每次操作能翻转一个区间，代价为这个区间的长度 在$O(nlogn)$的总代价内将整个序列排序 $$\text{ 归并排序 }$$ 从中间断开为左右区间 递归对两边分治 对已经有序的两边区间进行归并 123456789101112void work(int L,int R)&#123; if (L==R) return; work(L,Mid); work(Mid+1,R); int tl=L,tr=Mid+1,t=L; while (tl&lt;=Mid&amp;&amp;tr&lt;=R)&#123; if (A[tl]&lt;A[tr]) B[t++]=A[tl++];else B[t++]=A[tr++]; &#125; while (tl&lt;=Mid) B[t++]=A[tl++]; while (tr&lt;=R) B[t++]=A[tr++]; for (int i=L;i&lt;=R;i++) A[i]=B[i];&#125; STL大法吼！区间合并：inplace_merge 12//a[0..n-1],a[n..n*2-1]合并inplace_merge(a,a+n,a+n*2); 扩展：归并排序求逆序对 $$\text{ 不基于比较的排序算法 }$$ $$\text{ 桶排序 }$$一个萝卜一个坑 时间复杂度$O(n+m)$ $$\text{ 基数排序 }$$ 分段分别桶排，从低位到高位依次作为关键字 比如设当前所有数已经按后𝑘位排好了序，那么后𝑘+1位的排序就是按第𝑘+1位排，相同的就按原顺序排 视段长的大小，开这么多的桶，求出比𝑥小的数有多少个，然后快速把每个数放到该放的位置去。 [WC2017] 挑战]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>ZROI</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题 代码当然是可以的 12345#include &lt;iostream&gt;using namespace std;int main()&#123; return 0;&#125; latex qwq $1$]]></content>
      <categories>
        <category>测试文档</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
